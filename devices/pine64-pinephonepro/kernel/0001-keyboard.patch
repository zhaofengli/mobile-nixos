diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinephone-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinephone-pro.dts
index 520d998bae9ae8fe0981a5ce2b28ee812535604c..b705d5c7430d6174844966b95f597e387f71a143 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinephone-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinephone-pro.dts
@@ -85,6 +85,122 @@ bat: battery {
 			<3400000 0>;
         };
 
+        kb151_bat: kb151-battery {
+                compatible = "simple-battery";
+                voltage-min-design-microvolt = <3000000>;
+                voltage-max-design-microvolt = <4200000>;
+                energy-full-design-microwatt-hours = <20000000>;
+                charge-full-design-microamp-hours = <6000000>;
+                precharge-current-microamp = <130000>;
+                charge-term-current-microamp = <50000>;
+                constant-charge-current-max-microamp = <2000000>;
+                constant-charge-voltage-max-microvolt = <4200000>;
+                factory-internal-resistance-micro-ohms = <187000>;
+                ocv-capacity-celsius = <20>;
+                ocv-capacity-table-0 =
+                	<4147328 100>,
+			<4132636 99>,
+			<4121720 98>,
+			<4110905 97>,
+			<4102063 96>,
+			<4092428 95>,
+			<4082371 94>,
+			<4074137 93>,
+			<4064172 92>,
+			<4056387 91>,
+			<4047198 90>,
+			<4038599 89>,
+			<4030933 88>,
+			<4021831 87>,
+			<4012613 86>,
+			<4003863 85>,
+			<3995132 84>,
+			<3986108 83>,
+			<3977434 82>,
+			<3967977 81>,
+			<3960286 80>,
+			<3951737 79>,
+			<3943518 78>,
+			<3935723 77>,
+			<3928692 76>,
+			<3920093 75>,
+			<3912676 74>,
+			<3905481 73>,
+			<3899881 72>,
+			<3892341 71>,
+			<3887140 70>,
+			<3880005 69>,
+			<3876060 68>,
+			<3869195 67>,
+			<3863234 66>,
+			<3857808 65>,
+			<3851464 64>,
+			<3846976 63>,
+			<3840724 62>,
+			<3835254 61>,
+			<3830946 60>,
+			<3826564 59>,
+			<3821275 58>,
+			<3817413 57>,
+			<3811941 56>,
+			<3808947 55>,
+			<3804959 54>,
+			<3800958 53>,
+			<3797447 52>,
+			<3794303 51>,
+			<3790341 50>,
+			<3787022 49>,
+			<3783436 48>,
+			<3779936 47>,
+			<3776176 46>,
+			<3772160 45>,
+			<3769348 44>,
+			<3766705 43>,
+			<3762481 42>,
+			<3760894 41>,
+			<3758396 40>,
+			<3755803 39>,
+			<3753543 38>,
+			<3749691 37>,
+			<3747026 36>,
+			<3743937 35>,
+			<3741872 34>,
+			<3738529 33>,
+			<3737528 32>,
+			<3734059 31>,
+			<3731586 30>,
+			<3728576 29>,
+			<3725939 28>,
+			<3721208 27>,
+			<3718239 26>,
+			<3713032 25>,
+			<3709785 24>,
+			<3704045 23>,
+			<3701203 22>,
+			<3695965 21>,
+			<3691074 20>,
+			<3684562 19>,
+			<3679140 18>,
+			<3670993 17>,
+			<3664243 16>,
+			<3655383 15>,
+			<3647666 14>,
+			<3642747 13>,
+			<3637775 12>,
+			<3632593 11>,
+			<3627120 10>,
+			<3620923 9>,
+			<3611465 8>,
+			<3597536 7>,
+			<3577366 6>,
+			<3545253 5>,
+			<3497377 4>,
+			<3430377 3>,
+			<3337780 2>,
+			<3183953 1>,
+			<3064061 0>;
+        };
+
 	cluster1_opp_ppp: opp-table1b {
 		compatible = "operating-points-v2";
 		opp-shared;
@@ -953,6 +1069,24 @@ ak09911: compass@c {
 	};
 };
 
+/* This bus is exposed on POGO pins */
+&i2c5 {
+	i2c-scl-rising-time-ns = <450>;
+	i2c-scl-falling-time-ns = <15>;
+	pinctrl-0 = <&i2c5_xfer &pogo_int_pin>;
+	status = "okay";
+
+	keyboard@15 {
+		compatible = "pine64,kb151";
+		reg = <0x15>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <RK_PA0 IRQ_TYPE_EDGE_FALLING>;
+		vbat-supply = <&vcc5v0_sys>;
+		wakeup-source;
+		monitored-battery = <&kb151_bat>;
+	};
+};
+
 &i2s0 {
 	rockchip,playback-channels = <2>;
 	rockchip,capture-channels = <2>;
@@ -1119,6 +1253,12 @@ vsel2_pin: vsel2-pin {
 		};
 	};
 
+	pogo {
+		pogo_int_pin: pogo-int {
+			rockchip,pins = <3 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
 	sdcard {
 		sdmmc0_pwr_h: sdmmc0-pwr-h {
 			rockchip,pins = <0 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
diff --git a/arch/arm64/configs/pinephonepro_defconfig b/arch/arm64/configs/pinephonepro_defconfig
index bd5541ef26ac26293ae451110b0c162225cdfd1f..53834a93d6adeda3a084a98b7d3a44ed3af03547 100644
--- a/arch/arm64/configs/pinephonepro_defconfig
+++ b/arch/arm64/configs/pinephonepro_defconfig
@@ -610,6 +610,7 @@ CONFIG_KEYBOARD_ADC=m
 CONFIG_KEYBOARD_GPIO=y
 CONFIG_KEYBOARD_GPIO_POLLED=m
 CONFIG_KEYBOARD_MATRIX=m
+CONFIG_KEYBOARD_KB151=m
 # CONFIG_INPUT_MOUSE is not set
 CONFIG_INPUT_TABLET=y
 CONFIG_INPUT_TOUCHSCREEN=y
@@ -675,6 +676,7 @@ CONFIG_POWER_RESET_SYSCON=y
 CONFIG_POWER_RESET_SYSCON_POWEROFF=y
 CONFIG_SYSCON_REBOOT_MODE=m
 CONFIG_NVMEM_REBOOT_MODE=m
+CONFIG_IP5XXX_POWER=y
 CONFIG_CHARGER_GPIO=y
 CONFIG_BATTERY_RK818=y
 CONFIG_CHARGER_RK818=y
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index 0c607da9ee10d3f540e53e89da65306eb356a219..cdcbf8232c1ad6d6735f76d216bdebeeab02dc9f 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -353,6 +353,16 @@ config KEYBOARD_HP7XX
 	  To compile this driver as a module, choose M here: the
 	  module will be called jornada720_kbd.
 
+config KEYBOARD_KB151
+	tristate "Pine64 KB151 Keyboard"
+	depends on I2C
+	select CRC8
+	select INPUT_MATRIXKMAP
+	help
+	  Say Y here to enable support for the KB151 keyboard used in the
+	  Pine64 PinePhone keyboard case. This driver supports the FLOSS
+	  firmware available at https://megous.com/git/pinephone-keyboard/
+
 config KEYBOARD_LM8323
 	tristate "LM8323 keypad chip"
 	depends on I2C
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index e3c8648f834ef480335b918a22413f17fa6aa160..1a7010f5d6767c1198c6045f1bd58f1e4b5aa2e9 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_KEYBOARD_IMX)		+= imx_keypad.o
 obj-$(CONFIG_KEYBOARD_IMX_SC_KEY)	+= imx_sc_key.o
 obj-$(CONFIG_KEYBOARD_HP6XX)		+= jornada680_kbd.o
 obj-$(CONFIG_KEYBOARD_HP7XX)		+= jornada720_kbd.o
+obj-$(CONFIG_KEYBOARD_KB151)		+= kb151.o
 obj-$(CONFIG_KEYBOARD_LKKBD)		+= lkkbd.o
 obj-$(CONFIG_KEYBOARD_LM8323)		+= lm8323.o
 obj-$(CONFIG_KEYBOARD_LM8333)		+= lm8333.o
diff --git a/drivers/input/keyboard/kb151.c b/drivers/input/keyboard/kb151.c
new file mode 100644
index 0000000000000000000000000000000000000000..17acd4b6cf9269c4e1a5a8db6ba6a83ca3e59ca4
--- /dev/null
+++ b/drivers/input/keyboard/kb151.c
@@ -0,0 +1,603 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (C) 2021 Samuel Holland <samuel@sholland.org>
+// Copyright (C) 2022 Ond≈ôej Jirman <megi@xff.cz>
+
+#include <linux/crc8.h>
+#include <linux/i2c.h>
+#include <linux/input/matrix_keypad.h>
+#include <dt-bindings/input/input.h>
+#include <linux/interrupt.h>
+#include <linux/regmap.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/pm_wakeirq.h>
+#include <linux/regulator/consumer.h>
+
+#define KB151_CRC8_POLYNOMIAL		0x07
+
+#define KB151_DEVICE_ID_HI		0x00
+#define KB151_DEVICE_ID_HI_VALUE	0x4b
+#define KB151_DEVICE_ID_LO		0x01
+#define KB151_DEVICE_ID_LO_VALUE	0x42
+#define KB151_FW_REVISION		0x02
+#define KB151_FW_FEATURES		0x03
+#define KB151_MATRIX_SIZE		0x06
+#define KB151_SCAN_CRC			0x07
+#define KB151_SCAN_DATA			0x08
+#define KB151_SYS_CONFIG		0x20
+#define KB151_SYS_CONFIG_DISABLE_SCAN	BIT(0)
+
+/* imported from firmware/registers.h */
+
+#define REG_DEVID_K		0x00
+#define REG_DEVID_B		0x01
+#define REG_FW_REVISION		0x02
+#define REG_FW_FEATURES		0x03
+#define REG_FW_FEATURES_USB_DEBUGGER	BIT(0)
+#define REG_FW_FEATURES_FLASHING_MODE	BIT(1)
+#define REG_FW_FEATURES_SELF_TEST	BIT(2)
+#define REG_FW_FEATURES_STOCK_FW	BIT(3)
+#define REG_FW_FEATURES_I2CA		BIT(4)
+
+#define REG_KEYMATRIX_SIZE	0x06
+#define REG_KEYMATRIX_STATE_CRC8 0x07
+#define REG_KEYMATRIX_STATE	0x08
+#define REG_KEYMATRIX_STATE_END	0x13
+
+#define REG_SYS_CONFIG		0x20
+#define REG_SYS_CONFIG_SCAN_BLOCK	BIT(0)
+
+#define REG_SYS_CHG_ADDR	0x21
+#define REG_SYS_CHG_DATA	0x22
+
+#define REG_SYS_COMMAND		0x23
+#define REG_SYS_COMMAND_MCU_RESET	'r'
+#define REG_SYS_COMMAND_USB_IAP		'i'
+#define REG_SYS_COMMAND_SELFTEST	't'
+#define REG_SYS_COMMAND_CHG_READ	0x91
+#define REG_SYS_COMMAND_CHG_WRITE	0xA1
+
+#define REG_SYS_USER_APP_BLOCK	0x24
+#define REG_SYS_USER_APP_BLOCK_MAGIC	0x53
+
+#define REG_FLASH_DATA_START	0x70
+#define REG_FLASH_DATA_END	0xef
+#define REG_FLASH_ADDR_L	0xf0
+#define REG_FLASH_ADDR_H	0xf1
+#define REG_FLASH_CRC8		0xf2
+
+#define REG_FLASH_UNLOCK	0xf3
+#define REG_FLASH_UNLOCK_MAGIC	0x46
+
+#define REG_FLASH_CMD		0xf4
+#define REG_FLASH_CMD_READ_ROM	0x52
+#define REG_FLASH_CMD_WRITE_ROM	0x57
+#define REG_FLASH_CMD_ERASE_ROM	0x45
+#define REG_FLASH_CMD_COMMIT	0x43
+
+#define REG_DEBUG_LOG		0xff
+
+/* default regmap from the factory */
+
+#define DEFAULT_MAP_ROWS 12
+#define DEFAULT_MAP_COLS 12
+
+static bool disable_input;
+module_param(disable_input, bool, S_IRUGO);
+MODULE_PARM_DESC(disable_input, "Disable the keyboard part of the driver");
+
+static bool disable_fn_layer;
+module_param(disable_fn_layer, bool, 0644);
+MODULE_PARM_DESC(disable_fn_layer, "Disable the keyboard's Fn key layer map");
+
+static const u32 kb151_default_keymap[] = {
+	MATRIX_KEY(0,  0, KEY_ESC),
+	MATRIX_KEY(0,  1, KEY_1),
+	MATRIX_KEY(0,  2, KEY_2),
+	MATRIX_KEY(0,  3, KEY_3),
+	MATRIX_KEY(0,  4, KEY_4),
+	MATRIX_KEY(0,  5, KEY_5),
+	MATRIX_KEY(0,  6, KEY_6),
+	MATRIX_KEY(0,  7, KEY_7),
+	MATRIX_KEY(0,  8, KEY_8),
+	MATRIX_KEY(0,  9, KEY_9),
+	MATRIX_KEY(0, 10, KEY_0),
+	MATRIX_KEY(0, 11, KEY_BACKSPACE),
+	MATRIX_KEY(1,  0, KEY_TAB),
+	MATRIX_KEY(1,  1, KEY_Q),
+	MATRIX_KEY(1,  2, KEY_W),
+	MATRIX_KEY(1,  3, KEY_E),
+	MATRIX_KEY(1,  4, KEY_R),
+	MATRIX_KEY(1,  5, KEY_T),
+	MATRIX_KEY(1,  6, KEY_Y),
+	MATRIX_KEY(1,  7, KEY_U),
+	MATRIX_KEY(1,  8, KEY_I),
+	MATRIX_KEY(1,  9, KEY_O),
+	MATRIX_KEY(1, 10, KEY_P),
+	MATRIX_KEY(1, 11, KEY_ENTER),
+	MATRIX_KEY(2,  0, KEY_LEFTMETA),
+	MATRIX_KEY(2,  1, KEY_A),
+	MATRIX_KEY(2,  2, KEY_S),
+	MATRIX_KEY(2,  3, KEY_D),
+	MATRIX_KEY(2,  4, KEY_F),
+	MATRIX_KEY(2,  5, KEY_G),
+	MATRIX_KEY(2,  6, KEY_H),
+	MATRIX_KEY(2,  7, KEY_J),
+	MATRIX_KEY(2,  8, KEY_K),
+	MATRIX_KEY(2,  9, KEY_L),
+	MATRIX_KEY(2, 10, KEY_SEMICOLON),
+	MATRIX_KEY(3,  0, KEY_LEFTSHIFT),
+	MATRIX_KEY(3,  1, KEY_Z),
+	MATRIX_KEY(3,  2, KEY_X),
+	MATRIX_KEY(3,  3, KEY_C),
+	MATRIX_KEY(3,  4, KEY_V),
+	MATRIX_KEY(3,  5, KEY_B),
+	MATRIX_KEY(3,  6, KEY_N),
+	MATRIX_KEY(3,  7, KEY_M),
+	MATRIX_KEY(3,  8, KEY_COMMA),
+	MATRIX_KEY(3,  9, KEY_DOT),
+	MATRIX_KEY(3, 10, KEY_SLASH),
+	MATRIX_KEY(4,  1, KEY_LEFTCTRL),
+	MATRIX_KEY(4,  4, KEY_SPACE),
+	MATRIX_KEY(4,  6, KEY_APOSTROPHE),
+	MATRIX_KEY(4,  8, KEY_RIGHTBRACE),
+	MATRIX_KEY(4,  9, KEY_LEFTBRACE),
+	MATRIX_KEY(5,  2, KEY_FN),
+	MATRIX_KEY(5,  3, KEY_LEFTALT),
+	MATRIX_KEY(5,  5, KEY_RIGHTALT),
+
+	/* FN layer */
+	MATRIX_KEY(6,  1, KEY_BACKSLASH), // |
+	MATRIX_KEY(6,  2, KEY_BACKSLASH),
+	MATRIX_KEY(6,  3, KEY_DOLLAR),
+	MATRIX_KEY(6,  4, KEY_EURO),
+	MATRIX_KEY(6,  5, KEY_GRAVE), // ~
+	MATRIX_KEY(6,  6, KEY_GRAVE),
+	MATRIX_KEY(6,  7, KEY_MINUS), // _
+	MATRIX_KEY(6,  8, KEY_EQUAL),
+	MATRIX_KEY(6,  9, KEY_MINUS),
+	MATRIX_KEY(6, 10, KEY_EQUAL),
+	MATRIX_KEY(6, 11, KEY_DELETE),
+
+	MATRIX_KEY(8,  0, KEY_SYSRQ),
+	MATRIX_KEY(8, 10, KEY_INSERT),
+
+	MATRIX_KEY(9,  0, KEY_LEFTSHIFT),
+	MATRIX_KEY(9,  8, KEY_HOME),
+	MATRIX_KEY(9,  9, KEY_UP),
+	MATRIX_KEY(9, 10, KEY_END),
+
+	MATRIX_KEY(10, 1, KEY_LEFTCTRL),
+	MATRIX_KEY(10, 6, KEY_LEFT),
+	MATRIX_KEY(10, 8, KEY_RIGHT),
+	MATRIX_KEY(10, 9, KEY_DOWN),
+
+	MATRIX_KEY(11, 2, KEY_FN),
+	MATRIX_KEY(11, 3, KEY_LEFTALT),
+	MATRIX_KEY(11, 5, KEY_RIGHTALT),
+};
+
+static const struct matrix_keymap_data kb151_default_keymap_data = {
+	.keymap = kb151_default_keymap,
+	.keymap_size = ARRAY_SIZE(kb151_default_keymap),
+};
+
+struct kb151 {
+	struct input_dev *input;
+	struct regulator *vbat_supply;
+	u8 crc_table[CRC8_TABLE_SIZE];
+	u8 row_shift;
+	u8 rows;
+	u8 cols;
+	u8 fn_state;
+	u8 buf_swap;
+	u8 buf[];
+};
+
+static void kb151_update(struct i2c_client *client)
+{
+	struct kb151 *kb151 = i2c_get_clientdata(client);
+	unsigned short *keymap = kb151->input->keycode;
+	struct device *dev = &client->dev;
+	size_t buf_len = kb151->cols + 1;
+	u8 *old_buf = kb151->buf;
+	u8 *new_buf = kb151->buf;
+	int col, crc, ret, row;
+
+	if (kb151->buf_swap)
+		old_buf += buf_len;
+	else
+		new_buf += buf_len;
+
+	ret = i2c_smbus_read_i2c_block_data(client, KB151_SCAN_CRC,
+					    buf_len, new_buf);
+	if (ret != buf_len) {
+		dev_err(dev, "Failed to read scan data: %d\n", ret);
+		return;
+	}
+
+	dev_dbg(dev, "%02x | %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
+		new_buf[0], new_buf[1], new_buf[2], new_buf[3], new_buf[4], new_buf[5],
+		new_buf[6], new_buf[7], new_buf[8], new_buf[9], new_buf[10], new_buf[11],
+		new_buf[12]);
+	crc = crc8(kb151->crc_table, new_buf + 1, kb151->cols, CRC8_INIT_VALUE);
+	if (crc != new_buf[0]) {
+		dev_err(dev, "Bad scan data (%02x != %02x)\n",
+			crc, new_buf[0]);
+		return;
+	}
+
+	for (col = 0; col < kb151->cols; ++col) {
+		u8 old = *(++old_buf);
+		u8 new = *(++new_buf);
+		u8 changed = old ^ new;
+
+		for (row = 0; row < kb151->rows; ++row) {
+			u8 pressed = new & BIT(row);
+			u8 map_row = row + (kb151->fn_state ? kb151->rows : 0);
+			int code = MATRIX_SCAN_CODE(map_row, col, kb151->row_shift);
+
+			if (!(changed & BIT(row)))
+				continue;
+
+			dev_dbg(&client->dev, "row %u col %u %sed\n",
+				map_row, col, pressed ? "press" : "releas");
+			if (keymap[code] == KEY_FN && !disable_fn_layer) {
+				dev_dbg(&client->dev, "FN is now %s\n",
+					pressed ? "pressed" : "released");
+				kb151->fn_state = pressed;
+			} else {
+				input_report_key(kb151->input, keymap[code], pressed);
+			}
+		}
+	}
+	input_sync(kb151->input);
+
+	kb151->buf_swap = !kb151->buf_swap;
+}
+
+static int kb151_open(struct input_dev *input)
+{
+	struct i2c_client *client = input_get_drvdata(input);
+	struct device *dev = &client->dev;
+	int ret, val;
+
+	ret = i2c_smbus_read_byte_data(client, KB151_SYS_CONFIG);
+	if (ret < 0) {
+		dev_err(dev, "Failed to read config: %d\n", ret);
+		return ret;
+	}
+
+	val = ret & ~KB151_SYS_CONFIG_DISABLE_SCAN;
+	ret = i2c_smbus_write_byte_data(client, KB151_SYS_CONFIG, val);
+	if (ret) {
+		dev_err(dev, "Failed to write config: %d\n", ret);
+		return ret;
+	}
+
+	kb151_update(client);
+
+	enable_irq(client->irq);
+
+	return 0;
+}
+
+static void kb151_close(struct input_dev *input)
+{
+	struct i2c_client *client = input_get_drvdata(input);
+	struct device *dev = &client->dev;
+	int ret, val;
+
+	disable_irq(client->irq);
+
+	ret = i2c_smbus_read_byte_data(client, KB151_SYS_CONFIG);
+	if (ret < 0) {
+		dev_err(dev, "Failed to read config: %d\n", ret);
+		return;
+	}
+
+	val = ret | KB151_SYS_CONFIG_DISABLE_SCAN;
+	ret = i2c_smbus_write_byte_data(client, KB151_SYS_CONFIG, val);
+	if (ret) {
+		dev_err(dev, "Failed to write config: %d\n", ret);
+	}
+}
+
+static irqreturn_t kb151_irq_thread(int irq, void *data)
+{
+	struct i2c_client *client = data;
+
+	kb151_update(client);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_IP5XXX_POWER
+
+static int kb151_charger_regmap_read(void *context,
+				     unsigned int reg, unsigned int *val)
+{
+	struct i2c_client *client = context;
+	int ret, i;
+
+	// initiate read of data from the charger
+	uint8_t buf[4] = { REG_SYS_CHG_ADDR, reg, 0xAA, REG_SYS_COMMAND_CHG_READ };
+	struct i2c_msg msgs[] = {
+		{ client->addr, 0, 4, buf },
+	};
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret < 0) {
+		dev_err(&client->dev, "Charger read failed (%d)\n", ret);
+		return ret;
+	}
+
+	for (i = 0; i < 5; i++) {
+		// read the result
+		uint8_t buf2[1] = { REG_SYS_CHG_DATA, };
+		uint8_t buf3[2] = { };
+		struct i2c_msg msgs2[] = {
+			{ client->addr, 0, 1, buf2 },
+			{ client->addr, I2C_M_RD, sizeof(buf3), buf3 },
+		};
+
+		usleep_range(700, 1200);
+
+		ret = i2c_transfer(client->adapter, msgs2, ARRAY_SIZE(msgs2));
+		if (ret < 0) {
+			dev_err(&client->dev, "Charger read failed (%d)\n", ret);
+			return ret;
+		}
+
+		dev_dbg(&client->dev, "rd %02x %02x\n", buf3[0], buf3[1]);
+
+		if (buf3[1] == REG_SYS_COMMAND_CHG_READ)
+			continue;
+
+		if (buf3[1] == 0) {
+			*val = buf3[0];
+			return 0;
+		}
+
+		if (buf3[1] == 0xff) {
+			dev_err(&client->dev,
+				"Charger read failed - MCU returned 0x%hhx\n",
+				buf3[1]);
+			return -EXDEV;
+		}
+	}
+
+	dev_err(&client->dev, "Charger read failed - timeout (%d)\n", ret);
+	return -ETIMEDOUT;
+}
+
+static int kb151_charger_regmap_write(void *context, unsigned int reg, unsigned int val)
+{
+	struct i2c_client *client = context;
+	int ret, i;
+
+	uint8_t buf[4] = { REG_SYS_CHG_ADDR, reg, val, REG_SYS_COMMAND_CHG_WRITE };
+	struct i2c_msg msgs[] = {
+		{ client->addr, 0, 4, buf },
+	};
+
+	dev_dbg(&client->dev, "wr 0x%02hhx: %02hhx\n", reg, val);
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret < 0) {
+		dev_err(&client->dev, "Charger write failed (%d)\n", ret);
+		return ret;
+	}
+
+	for (i = 0; i < 5; i++) {
+		// read the result
+		uint8_t buf2[1] = { REG_SYS_COMMAND, };
+		uint8_t buf3[1] = { };
+		struct i2c_msg msgs2[] = {
+			{ client->addr, 0, 1, buf2 },
+			{ client->addr, I2C_M_RD, sizeof(buf3), buf3 },
+		};
+
+		usleep_range(700, 1200);
+
+		ret = i2c_transfer(client->adapter, msgs2, ARRAY_SIZE(msgs2));
+		if (ret < 0) {
+			dev_err(&client->dev, "Charger write failed (%d)\n", ret);
+			return ret;
+		}
+
+		if (buf3[0] == REG_SYS_COMMAND_CHG_WRITE)
+			continue;
+
+		if (buf3[0] == 0)
+			return 0;
+
+		if (buf3[0] == 0xff) {
+			dev_err(&client->dev,
+				"Charger write failed - MCU returned 0x%hhx\n",
+				buf2[1]);
+			return -EXDEV;
+		}
+	}
+
+	dev_err(&client->dev, "Charger write failed - timeout (%d)\n", ret);
+	return -ETIMEDOUT;
+}
+
+static struct regmap_bus kb151_charger_regmap_bus = {
+	.reg_write = kb151_charger_regmap_write,
+	.reg_read = kb151_charger_regmap_read,
+};
+
+static struct regmap_config kb151_charger_regmap_config = {
+        .reg_bits       = 8,
+        .reg_stride     = 1,
+        .val_bits       = 8,
+        .max_register   = 0xff,
+        .cache_type     = REGCACHE_NONE,
+};
+
+extern int ip5xxx_power_probe_with_regmap(struct device* dev, struct regmap *regmap);
+
+#endif
+
+static int kb151_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	u8 info[KB151_MATRIX_SIZE + 1];
+	unsigned int kb_rows, kb_cols;
+	unsigned int map_rows = DEFAULT_MAP_ROWS, map_cols = DEFAULT_MAP_COLS;
+	struct kb151 *kb151;
+#ifdef CONFIG_IP5XXX_POWER
+	struct regmap* regmap;
+#endif
+	bool has_of_keymap;
+	int ret;
+
+	has_of_keymap = of_property_read_bool(dev->of_node, "linux,keymap");
+
+	ret = i2c_smbus_read_i2c_block_data(client, 0, sizeof(info), info);
+	if (ret != sizeof(info)) {
+		dev_err(dev, "KB151 was not detected on the bus (%d)\n", ret);
+		return ret;
+	}
+
+	if (info[KB151_DEVICE_ID_HI] != KB151_DEVICE_ID_HI_VALUE ||
+	    info[KB151_DEVICE_ID_LO] != KB151_DEVICE_ID_LO_VALUE) {
+		dev_warn(dev, "Device on address %hu doesn't look like KB151\n",
+			 client->addr);
+		return -ENODEV;
+	}
+
+	dev_info(dev, "Found KB151 with firmware %d.%d (features=%#x)\n",
+		 info[KB151_FW_REVISION] >> 4,
+		 info[KB151_FW_REVISION] & 0xf,
+		 info[KB151_FW_FEATURES]);
+
+	if (has_of_keymap) {
+		ret = matrix_keypad_parse_properties(dev, &map_rows, &map_cols);
+		if (ret)
+			return ret;
+	}
+
+	kb_rows = info[KB151_MATRIX_SIZE] & 0xf;
+	kb_cols = info[KB151_MATRIX_SIZE] >> 4;
+	if (map_rows != 2 * kb_rows || map_cols != kb_cols) {
+		dev_err(dev, "Keyboard matrix is %ux%u, but key map is %ux%u\n",
+			kb_rows, kb_cols, map_rows, map_cols);
+		return -EINVAL;
+	}
+
+	/* Allocate two buffers, and include space for the CRC. */
+	kb151 = devm_kzalloc(dev, struct_size(kb151, buf, 2 * (kb_cols + 1)), GFP_KERNEL);
+	if (!kb151)
+		return -ENOMEM;
+
+	kb151->vbat_supply = devm_regulator_get(dev, "vbat");
+	if (IS_ERR(kb151->vbat_supply))
+		return dev_err_probe(dev, PTR_ERR(kb151->vbat_supply),
+				     "Failed to get vbat_supply\n");
+
+	i2c_set_clientdata(client, kb151);
+
+	crc8_populate_msb(kb151->crc_table, KB151_CRC8_POLYNOMIAL);
+
+	kb151->row_shift = get_count_order(kb_cols);
+	kb151->rows = kb_rows;
+	kb151->cols = kb_cols;
+
+	if (disable_input)
+		goto charger;
+
+	kb151->input = devm_input_allocate_device(dev);
+	if (!kb151->input)
+		return -ENOMEM;
+
+	input_set_drvdata(kb151->input, client);
+
+	kb151->input->name = client->name;
+	kb151->input->phys = "kb151/input0";
+	kb151->input->id.bustype = BUS_I2C;
+	kb151->input->open = kb151_open;
+	kb151->input->close = kb151_close;
+
+	__set_bit(EV_REP, kb151->input->evbit);
+
+	ret = matrix_keypad_build_keymap(has_of_keymap ? NULL : &kb151_default_keymap_data,
+					 NULL, map_rows, map_cols,
+					 NULL, kb151->input);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to build keymap\n");
+
+	ret = devm_request_threaded_irq(dev, client->irq,
+					NULL, kb151_irq_thread,
+					IRQF_ONESHOT | IRQF_NO_AUTOEN,
+					client->name, client);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to request IRQ\n");
+
+	ret = input_register_device(kb151->input);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to register input\n");
+
+charger:
+#ifdef CONFIG_IP5XXX_POWER
+	// we need to create a custom regmap_bus that will proxy
+	// charger register reads/writes via a keyboard MCU
+	regmap = __regmap_lockdep_wrapper(__devm_regmap_init,
+		 "kb151-charger-regmap", dev,
+		  &kb151_charger_regmap_bus, client,
+		  &kb151_charger_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "Failed to create charger regmap (%ld)\n", PTR_ERR(regmap));
+		return PTR_ERR(regmap);
+	}
+
+	// initialize the charger
+	ret = ip5xxx_power_probe_with_regmap(dev, regmap);
+	if (ret) {
+		dev_err(dev, "Failed to initialize keyboard charger (%d)\n", ret);
+		return ret;
+	}
+#else
+	dev_warn(dev, "Your kernel doesn't have CONFIG_IP5XXX_POWER enabled, keyboard charger support is disabled.\n");
+#endif
+
+	ret = regulator_enable(kb151->vbat_supply);
+	if (ret) {
+		dev_err(dev, "Failed to enable keyboard vbat supply (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int kb151_remove(struct i2c_client *client)
+{
+	struct kb151 *kb151 = i2c_get_clientdata(client);
+
+	regulator_disable(kb151->vbat_supply);
+
+	return 0;
+}
+
+static const struct of_device_id kb151_of_match[] = {
+	{ .compatible = "pine64,kb151" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, kb151_of_match);
+
+static struct i2c_driver kb151_driver = {
+	.probe_new	= kb151_probe,
+	.remove		= kb151_remove,
+	.driver		= {
+		.name		= "kb151",
+		.of_match_table = kb151_of_match,
+	},
+};
+module_i2c_driver(kb151_driver);
+
+MODULE_AUTHOR("Samuel Holland <samuel@sholland.org>");
+MODULE_DESCRIPTION("Pine64 KB151 keyboard driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index 6bf0834b5f888f8897be04d2187232c91acb614e..819e1f3098e07d4800df256dacfc237a7a3113b9 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -51,6 +51,14 @@ config GENERIC_ADC_BATTERY
 	  Say Y here to enable support for the generic battery driver
 	  which uses IIO framework to read adc.
 
+config IP5XXX_POWER
+	tristate "Injoinic IP5xxx charger driver"
+	depends on I2C
+	select REGMAP_I2C
+	help
+	  Say Y to include support for Injoinic IP5xxx (including IP5209)
+	  charger ICs.
+
 config MAX8925_POWER
 	tristate "MAX8925 battery charger support"
 	depends on MFD_MAX8925
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 3a1526f7db4560f47f8b0227120ac8804d326cad..49342df12a6fd7956b1ea57373a62674e37e706a 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_GENERIC_ADC_BATTERY)	+= generic-adc-battery.o
 obj-$(CONFIG_PDA_POWER)		+= pda_power.o
 obj-$(CONFIG_APM_POWER)		+= apm_power.o
 obj-$(CONFIG_AXP20X_POWER)	+= axp20x_usb_power.o
+obj-$(CONFIG_IP5XXX_POWER)	+= ip5xxx_power.o
 obj-$(CONFIG_MAX8925_POWER)	+= max8925_power.o
 obj-$(CONFIG_WM831X_BACKUP)	+= wm831x_backup.o
 obj-$(CONFIG_WM831X_POWER)	+= wm831x_power.o
diff --git a/drivers/power/supply/ip5xxx_power.c b/drivers/power/supply/ip5xxx_power.c
new file mode 100644
index 0000000000000000000000000000000000000000..bb49cfe0a40c650dca3d53a9bd5643334e319f73
--- /dev/null
+++ b/drivers/power/supply/ip5xxx_power.c
@@ -0,0 +1,752 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (C) 2021 Samuel Holland <samuel@sholland.org>
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/power_supply.h>
+#include <linux/regmap.h>
+
+#define IP5XXX_SYS_CTL0			0x01
+#define IP5XXX_SYS_CTL0_WLED_DET_EN		BIT(4)
+#define IP5XXX_SYS_CTL0_WLED_EN			BIT(3)
+#define IP5XXX_SYS_CTL0_BOOST_EN		BIT(2)
+#define IP5XXX_SYS_CTL0_CHARGER_EN		BIT(1)
+#define IP5XXX_SYS_CTL1			0x02
+#define IP5XXX_SYS_CTL1_LIGHT_SHDN_EN		BIT(1)
+#define IP5XXX_SYS_CTL1_LOAD_PWRUP_EN		BIT(0)
+#define IP5XXX_SYS_CTL2			0x0c
+#define IP5XXX_SYS_CTL2_LIGHT_SHDN_TH		GENMASK(7, 3)
+#define IP5XXX_SYS_CTL3			0x03
+#define IP5XXX_SYS_CTL3_LONG_PRESS_TIME_SEL	GENMASK(7, 6)
+#define IP5XXX_SYS_CTL3_BTN_SHDN_EN		BIT(5)
+#define IP5XXX_SYS_CTL4			0x04
+#define IP5XXX_SYS_CTL4_SHDN_TIME_SEL		GENMASK(7, 6)
+#define IP5XXX_SYS_CTL4_VIN_PULLOUT_BOOST_EN	BIT(5)
+#define IP5XXX_SYS_CTL5			0x07
+#define IP5XXX_SYS_CTL5_NTC_EN			BIT(7)
+#define IP5XXX_SYS_CTL5_WLED_MODE_SEL		BIT(1)
+#define IP5XXX_SYS_CTL5_BTN_SHDN_SEL		BIT(0)
+#define IP5XXX_CHG_CTL1			0x22
+#define IP5XXX_CHG_CTL1_BOOST_UVP_SEL		GENMASK(3, 2)
+#define IP5XXX_CHG_CTL2			0x24
+#define IP5XXX_CHG_CTL2_BAT_TYPE_SEL		GENMASK(6, 5)
+#define IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_2V	(0x0 << 5)
+#define IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_3V	(0x1 << 5)
+#define IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_35V	(0x2 << 5)
+#define IP5XXX_CHG_CTL2_CONST_VOLT_SEL		GENMASK(2, 1)
+#define IP5XXX_CHG_CTL4			0x26
+#define IP5XXX_CHG_CTL4_BAT_TYPE_SEL_EN		BIT(6)
+#define IP5XXX_CHG_CTL4A		0x25
+#define IP5XXX_CHG_CTL4A_CONST_CUR_SEL		GENMASK(4, 0)
+#define IP5XXX_MFP_CTL0			0x51
+#define IP5XXX_MFP_CTL1			0x52
+#define IP5XXX_GPIO_CTL2		0x53
+#define IP5XXX_GPIO_CTL2A		0x54
+#define IP5XXX_GPIO_CTL3		0x55
+#define IP5XXX_READ0			0x71
+#define IP5XXX_READ0_CHG_STAT			GENMASK(7, 5)
+#define IP5XXX_READ0_CHG_STAT_IDLE		(0x0 << 5)
+#define IP5XXX_READ0_CHG_STAT_TRICKLE		(0x1 << 5)
+#define IP5XXX_READ0_CHG_STAT_CONST_VOLT	(0x2 << 5)
+#define IP5XXX_READ0_CHG_STAT_CONST_CUR		(0x3 << 5)
+#define IP5XXX_READ0_CHG_STAT_CONST_VOLT_STOP	(0x4 << 5)
+#define IP5XXX_READ0_CHG_STAT_FULL		(0x5 << 5)
+#define IP5XXX_READ0_CHG_STAT_TIMEOUT		(0x6 << 5)
+#define IP5XXX_READ0_CHG_OP			BIT(4)
+#define IP5XXX_READ0_CHG_END			BIT(3)
+#define IP5XXX_READ0_CONST_VOLT_TIMEOUT		BIT(2)
+#define IP5XXX_READ0_CHG_TIMEOUT		BIT(1)
+#define IP5XXX_READ0_TRICKLE_TIMEOUT		BIT(0)
+#define IP5XXX_READ0_TIMEOUT			GENMASK(2, 0)
+#define IP5XXX_READ1			0x72
+#define IP5XXX_READ1_WLED_PRESENT		BIT(7)
+#define IP5XXX_READ1_LIGHT_LOAD			BIT(6)
+#define IP5XXX_READ1_VIN_OVER_VOLT		BIT(5)
+#define IP5XXX_READ2			0x77
+#define IP5XXX_READ2_BTN_PRESS			BIT(3)
+#define IP5XXX_READ2_BTN_LONG_PRESS		BIT(1)
+#define IP5XXX_READ2_BTN_SHORT_PRESS		BIT(0)
+#define IP5XXX_BATVADC_DAT0		0xa2
+#define IP5XXX_BATVADC_DAT1		0xa3
+#define IP5XXX_BATIADC_DAT0		0xa4
+#define IP5XXX_BATIADC_DAT1		0xa5
+#define IP5XXX_BATOCV_DAT0		0xa8
+#define IP5XXX_BATOCV_DAT1		0xa9
+
+struct ip5xxx {
+	struct device *dev;
+	struct regmap *regmap;
+	struct delayed_work wd_work;
+	struct power_supply_battery_info bat;
+	int r_int;
+	bool initialized;
+};
+
+static const enum power_supply_property ip5xxx_boost_properties[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+};
+
+static int ip5xxx_boost_get_property(struct power_supply *psy,
+				     enum power_supply_property psp,
+				     union power_supply_propval *val)
+{
+	struct ip5xxx *ip5xxx = power_supply_get_drvdata(psy);
+	unsigned int rval;
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		ret = regmap_read(ip5xxx->regmap, IP5XXX_SYS_CTL0, &rval);
+		if (ret == -EXDEV) {
+			val->intval = 0;
+			return 0;
+		} else if (ret) {
+			return ret;
+		}
+
+		val->intval = !!(rval & IP5XXX_SYS_CTL0_BOOST_EN);
+		return 0;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		ret = regmap_read(ip5xxx->regmap, IP5XXX_CHG_CTL1, &rval);
+		if (ret == -EXDEV) {
+			val->intval = 4530000;
+			return 0;
+		} else if (ret) {
+			return ret;
+		}
+
+		rval &= IP5XXX_CHG_CTL1_BOOST_UVP_SEL;
+		val->intval = 4530000 + 100000 * (rval >> 2);
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ip5xxx_boost_set_property(struct power_supply *psy,
+				     enum power_supply_property psp,
+				     const union power_supply_propval *val)
+{
+	struct ip5xxx *ip5xxx = power_supply_get_drvdata(psy);
+	unsigned int rval;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		rval = val->intval ? IP5XXX_SYS_CTL0_BOOST_EN : 0;
+		return regmap_update_bits(ip5xxx->regmap, IP5XXX_SYS_CTL0,
+					  IP5XXX_SYS_CTL0_BOOST_EN, rval);
+
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		rval = ((val->intval - 4530000) / 100000) << 2;
+		return regmap_update_bits(ip5xxx->regmap, IP5XXX_CHG_CTL1,
+					  IP5XXX_CHG_CTL1_BOOST_UVP_SEL, rval);
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ip5xxx_boost_property_is_writeable(struct power_supply *psy,
+					      enum power_supply_property psp)
+{
+	return true;
+}
+
+static const struct power_supply_desc ip5xxx_boost_desc = {
+	.name			= "ip5xxx-boost",
+	.type			= POWER_SUPPLY_TYPE_MAINS,
+	.properties		= ip5xxx_boost_properties,
+	.num_properties		= ARRAY_SIZE(ip5xxx_boost_properties),
+	.get_property		= ip5xxx_boost_get_property,
+	.set_property		= ip5xxx_boost_set_property,
+	.property_is_writeable	= ip5xxx_boost_property_is_writeable,
+};
+
+static const enum power_supply_property ip5xxx_charger_properties[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CALIBRATE,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_OCV,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+};
+
+static int ip5xxx_charger_get_status(struct ip5xxx *ip5xxx, int *val)
+{
+	unsigned int rval;
+	int ret;
+
+	ret = regmap_read(ip5xxx->regmap, IP5XXX_READ0, &rval);
+	if (ret == -EXDEV) {
+		*val = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		return 0;
+	} else if (ret) {
+		return ret;
+	}
+
+	switch (rval & IP5XXX_READ0_CHG_STAT) {
+	case IP5XXX_READ0_CHG_STAT_IDLE:
+		*val = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case IP5XXX_READ0_CHG_STAT_TRICKLE:
+	case IP5XXX_READ0_CHG_STAT_CONST_CUR:
+	case IP5XXX_READ0_CHG_STAT_CONST_VOLT:
+		*val = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case IP5XXX_READ0_CHG_STAT_CONST_VOLT_STOP:
+	case IP5XXX_READ0_CHG_STAT_FULL:
+		*val = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case IP5XXX_READ0_CHG_STAT_TIMEOUT:
+		*val = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ip5xxx_charger_get_charge_type(struct ip5xxx *ip5xxx, int *val)
+{
+	unsigned int rval;
+	int ret;
+
+	ret = regmap_read(ip5xxx->regmap, IP5XXX_READ0, &rval);
+	if (ret) {
+		if (ret == -EXDEV) {
+			*val = POWER_SUPPLY_CHARGE_TYPE_NONE;
+			return 0;
+		}
+		return ret;
+	}
+
+	switch (rval & IP5XXX_READ0_CHG_STAT) {
+	case IP5XXX_READ0_CHG_STAT_IDLE:
+	case IP5XXX_READ0_CHG_STAT_CONST_VOLT_STOP:
+	case IP5XXX_READ0_CHG_STAT_FULL:
+	case IP5XXX_READ0_CHG_STAT_TIMEOUT:
+		*val = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	case IP5XXX_READ0_CHG_STAT_TRICKLE:
+		*val = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	case IP5XXX_READ0_CHG_STAT_CONST_CUR:
+	case IP5XXX_READ0_CHG_STAT_CONST_VOLT:
+		*val = POWER_SUPPLY_CHARGE_TYPE_STANDARD;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ip5xxx_charger_get_health(struct ip5xxx *ip5xxx, int *val)
+{
+	unsigned int rval;
+	int ret;
+
+	ret = regmap_read(ip5xxx->regmap, IP5XXX_READ0, &rval);
+	if (ret == -EXDEV) {
+		*val = POWER_SUPPLY_HEALTH_GOOD;
+		return 0;
+	} else if (ret) {
+		return ret;
+	}
+
+	if (rval & IP5XXX_READ0_TIMEOUT)
+		*val = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+	else
+		*val = POWER_SUPPLY_HEALTH_GOOD;
+
+	return 0;
+}
+
+static int ip5xxx_charger_get_voltage_max(struct ip5xxx *ip5xxx, int *val)
+{
+	unsigned int rval;
+	int ret;
+
+	ret = regmap_read(ip5xxx->regmap, IP5XXX_CHG_CTL2, &rval);
+	if (ret == -EXDEV) {
+		*val = 4200000;
+		return 0;
+	} else if (ret) {
+		return ret;
+	}
+
+	/*
+	 * It is not clear what this will return if
+	 * IP5XXX_CHG_CTL4_BAT_TYPE_SEL_EN is not set...
+	 */
+	switch (rval & IP5XXX_CHG_CTL2_BAT_TYPE_SEL) {
+	case IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_2V:
+		*val = 4200000;
+		break;
+	case IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_3V:
+		*val = 4300000;
+		break;
+	case IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_35V:
+		*val = 4350000;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ip5xxx_charger_read_adc(struct ip5xxx *ip5xxx,
+				   u8 lo_reg, u8 hi_reg, int *val)
+{
+	unsigned hi, lo;
+	int ret;
+
+	ret = regmap_read(ip5xxx->regmap, lo_reg, &lo);
+	if (ret)
+		return ret;
+
+	ret = regmap_read(ip5xxx->regmap, hi_reg, &hi);
+	if (ret)
+		return ret;
+
+	if (hi & 0x20)
+		*val = -(int)((~lo & 0xff) + ((~hi & 0x1f) << 8) + 1);
+	else
+		*val = hi << 8 | lo;
+
+	return 0;
+}
+
+static int ip5xxx_charger_get_voltage_now(struct ip5xxx *ip5xxx, int *val)
+{
+	int ret, raw;
+
+	ret = ip5xxx_charger_read_adc(ip5xxx, IP5XXX_BATVADC_DAT0,
+				      IP5XXX_BATVADC_DAT1, &raw);
+	if (ret == -EXDEV) {
+		*val = 0;
+		return 0;
+	} else if (ret) {
+		return ret;
+	}
+
+	*val = (2600 + DIV_ROUND_CLOSEST(raw * 1000, 3724)) * 1000;
+	return 0;
+}
+
+static int ip5xxx_charger_get_current_now(struct ip5xxx *ip5xxx, int *val)
+{
+	int ret, raw;
+
+	ret = ip5xxx_charger_read_adc(ip5xxx, IP5XXX_BATIADC_DAT0,
+				      IP5XXX_BATIADC_DAT1, &raw);
+	if (ret == -EXDEV) {
+		*val = 0;
+		return 0;
+	} else if (ret) {
+		return ret;
+	}
+
+	*val = DIV_ROUND_CLOSEST(raw * 1000, 1341) * 1000;
+	return 0;
+}
+
+static int ip5xxx_charger_get_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       union power_supply_propval *val)
+{
+	struct ip5xxx *ip5xxx = power_supply_get_drvdata(psy);
+	int raw, ret, vmax, cur, vol;
+	unsigned int rval;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		return ip5xxx_charger_get_status(ip5xxx, &val->intval);
+
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		return ip5xxx_charger_get_charge_type(ip5xxx, &val->intval);
+
+	case POWER_SUPPLY_PROP_PRESENT:
+		ret = regmap_read(ip5xxx->regmap, IP5XXX_READ0, &rval);
+		if (ret == -EXDEV) {
+			val->intval = 0;
+			return 0;
+		} else if (ret) {
+			return ret;
+		}
+		val->intval = 1;
+		return 0;
+
+	case POWER_SUPPLY_PROP_HEALTH:
+		return ip5xxx_charger_get_health(ip5xxx, &val->intval);
+
+	case POWER_SUPPLY_PROP_CAPACITY:
+		ret = ip5xxx_charger_get_voltage_now(ip5xxx, &vol);
+		if (ret)
+			return ret;
+
+		ret = ip5xxx_charger_get_current_now(ip5xxx, &cur);
+		if (ret)
+			return ret;
+
+		ret = power_supply_batinfo_ocv2cap(&ip5xxx->bat, vol - cur * ip5xxx->r_int / 1000, 20);
+		if (ret < 0)
+			return ret;
+			
+		val->intval = ret;
+		return 0;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		return ip5xxx_charger_get_voltage_max(ip5xxx, &val->intval);
+
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		return ip5xxx_charger_get_voltage_now(ip5xxx, &val->intval);
+
+	case POWER_SUPPLY_PROP_VOLTAGE_OCV:
+		ret = ip5xxx_charger_read_adc(ip5xxx, IP5XXX_BATOCV_DAT0,
+					      IP5XXX_BATOCV_DAT1, &raw);
+		if (ret == -EXDEV) {
+			val->intval = 0;
+			return 0;
+		} else if (ret) {
+			return ret;
+		}
+
+		val->intval = (2600 + DIV_ROUND_CLOSEST(raw * 1000, 3724)) * 1000;
+		return 0;
+
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		return ip5xxx_charger_get_current_now(ip5xxx, &val->intval);
+
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+		ret = regmap_read(ip5xxx->regmap, IP5XXX_CHG_CTL4A, &rval);
+		if (ret == -EXDEV) {
+			val->intval = 0;
+			return 0;
+		} else if (ret) {
+			return ret;
+		}
+
+		rval &= IP5XXX_CHG_CTL4A_CONST_CUR_SEL;
+		val->intval = 100000 * rval;
+		return 0;
+
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+		val->intval = 100000 * 0x1f;
+		return 0;
+
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+		ret = ip5xxx_charger_get_voltage_max(ip5xxx, &vmax);
+		if (ret == -EXDEV) {
+			val->intval = 4200000;
+			return 0;
+		} else if (ret) {
+			return ret;
+		}
+
+		ret = regmap_read(ip5xxx->regmap, IP5XXX_CHG_CTL2, &rval);
+		if (ret == -EXDEV) {
+			val->intval = 4200000;
+			return 0;
+		} else if (ret) {
+			return ret;
+		}
+
+		rval &= IP5XXX_CHG_CTL2_CONST_VOLT_SEL;
+		val->intval = vmax + 14000 * (rval >> 1);
+		return 0;
+
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		ret = ip5xxx_charger_get_voltage_max(ip5xxx, &vmax);
+		if (ret)
+			return ret;
+
+		val->intval = vmax + 14000 * 3;
+		return 0;
+
+	case POWER_SUPPLY_PROP_CALIBRATE:
+		val->intval = ip5xxx->r_int;
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ip5xxx_charger_set_voltage_max(struct ip5xxx *ip5xxx, int val)
+{
+	unsigned int rval;
+	int ret;
+
+	switch (val) {
+	case 4200000:
+		rval = IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_2V;
+		break;
+	case 4300000:
+		rval = IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_3V;
+		break;
+	case 4350000:
+		rval = IP5XXX_CHG_CTL2_BAT_TYPE_SEL_4_35V;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = regmap_update_bits(ip5xxx->regmap, IP5XXX_CHG_CTL2,
+				 IP5XXX_CHG_CTL2_BAT_TYPE_SEL, rval);
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(ip5xxx->regmap, IP5XXX_CHG_CTL4,
+				 IP5XXX_CHG_CTL4_BAT_TYPE_SEL_EN,
+				 IP5XXX_CHG_CTL4_BAT_TYPE_SEL_EN);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int ip5xxx_charger_set_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       const union power_supply_propval *val)
+{
+	struct ip5xxx *ip5xxx = power_supply_get_drvdata(psy);
+	unsigned int rval;
+	int ret, vmax;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		switch (val->intval) {
+		case POWER_SUPPLY_STATUS_CHARGING:
+			rval = IP5XXX_SYS_CTL0_CHARGER_EN;
+			break;
+		case POWER_SUPPLY_STATUS_DISCHARGING:
+		case POWER_SUPPLY_STATUS_NOT_CHARGING:
+			rval = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+		return regmap_update_bits(ip5xxx->regmap, IP5XXX_SYS_CTL0,
+					  IP5XXX_SYS_CTL0_CHARGER_EN, rval);
+
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		return ip5xxx_charger_set_voltage_max(ip5xxx, val->intval);
+
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+		rval = val->intval / 100000;
+		return regmap_update_bits(ip5xxx->regmap, IP5XXX_CHG_CTL4A,
+					  IP5XXX_CHG_CTL4A_CONST_CUR_SEL, rval);
+
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+		ret = ip5xxx_charger_get_voltage_max(ip5xxx, &vmax);
+		if (ret)
+			return ret;
+
+		rval = ((val->intval - vmax) / 14000) << 1;
+		return regmap_update_bits(ip5xxx->regmap, IP5XXX_CHG_CTL2,
+					  IP5XXX_CHG_CTL2_CONST_VOLT_SEL, rval);
+
+	case POWER_SUPPLY_PROP_CALIBRATE:
+		if (val->intval < 0 || val->intval > 1000)
+			return -EINVAL;
+		ip5xxx->r_int = val->intval;
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ip5xxx_charger_property_is_writeable(struct power_supply *psy,
+						enum power_supply_property psp)
+{
+	return psp == POWER_SUPPLY_PROP_STATUS ||
+	       psp == POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN ||
+	       psp == POWER_SUPPLY_PROP_CALIBRATE ||
+	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT ||
+	       psp == POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE;
+}
+
+static const struct power_supply_desc ip5xxx_charger_desc = {
+	.name			= "ip5xxx-charger",
+	.type			= POWER_SUPPLY_TYPE_BATTERY,
+	.properties		= ip5xxx_charger_properties,
+	.num_properties		= ARRAY_SIZE(ip5xxx_charger_properties),
+	.get_property		= ip5xxx_charger_get_property,
+	.set_property		= ip5xxx_charger_set_property,
+	.property_is_writeable	= ip5xxx_charger_property_is_writeable,
+};
+
+static const struct regmap_config ip5xxx_regmap_config = {
+	.reg_bits		= 8,
+	.val_bits		= 8,
+	.max_register		= IP5XXX_BATOCV_DAT1,
+};
+
+static void ip5xxx_power_wd_work(struct work_struct *work)
+{
+	struct ip5xxx *ip5xxx = container_of(work, struct ip5xxx, wd_work.work);
+	int ret;
+
+	if (ip5xxx->initialized) {
+		//XXX: perform some checks?
+		//- charger may reset some of its state when it's powered down
+		//  by the user and not accessible
+		schedule_delayed_work(&ip5xxx->wd_work, msecs_to_jiffies(5000));
+		return;
+	}
+
+	/*
+	 * Disable shutdown under light load (it turns off the keyboard).
+	 * Disable power on when under load (wait until I2C is pulled up).
+	 */
+	ret = regmap_update_bits(ip5xxx->regmap, IP5XXX_SYS_CTL1,
+				 IP5XXX_SYS_CTL1_LIGHT_SHDN_EN |
+				 IP5XXX_SYS_CTL1_LOAD_PWRUP_EN, 0);
+	if (ret)
+		goto err;
+
+	/*
+	 * Enable shutdown after two short button presses within 1 second.
+	 */
+	ret = regmap_update_bits(ip5xxx->regmap, IP5XXX_SYS_CTL3,
+				 IP5XXX_SYS_CTL3_BTN_SHDN_EN,
+				 IP5XXX_SYS_CTL3_BTN_SHDN_EN);
+	if (ret)
+		goto err;
+
+	/*
+	 * Disable power on when VIN is removed (wait until the phone is on).
+	 */
+	ret = regmap_update_bits(ip5xxx->regmap, IP5XXX_SYS_CTL4,
+				 IP5XXX_SYS_CTL4_VIN_PULLOUT_BOOST_EN, 0);
+	if (ret)
+		goto err;
+
+	/*
+	 * Enable the NTC.
+	 * Configure the button for two press => LED, long press => shutdown.
+	 */
+	ret = regmap_update_bits(ip5xxx->regmap, IP5XXX_SYS_CTL5,
+				 IP5XXX_SYS_CTL5_NTC_EN |
+				 IP5XXX_SYS_CTL5_WLED_MODE_SEL |
+				 IP5XXX_SYS_CTL5_BTN_SHDN_SEL,
+				 IP5XXX_SYS_CTL5_WLED_MODE_SEL |
+				 IP5XXX_SYS_CTL5_BTN_SHDN_SEL);
+	if (ret)
+		goto err;
+
+	ip5xxx->initialized = true;
+	schedule_delayed_work(&ip5xxx->wd_work, msecs_to_jiffies(5000));
+	dev_info(ip5xxx->dev, "Charger is initialized\n");
+	return;
+
+err:
+	dev_err(ip5xxx->dev, "Failed to initialize the charger\n");
+	schedule_delayed_work(&ip5xxx->wd_work, msecs_to_jiffies(5000));
+}
+
+static void ip5xxx_power_cleanup(void* data)
+{
+	struct ip5xxx *ip5xxx = data;
+
+	cancel_delayed_work_sync(&ip5xxx->wd_work);
+}
+
+int ip5xxx_power_probe_with_regmap(struct device* dev, struct regmap *regmap)
+{
+	struct power_supply_config psy_cfg = {};
+	struct power_supply *psy;
+	struct ip5xxx *ip5xxx;
+	int ret;
+
+	ip5xxx = devm_kzalloc(dev, sizeof(*ip5xxx), GFP_KERNEL);
+	if (!ip5xxx)
+		return -ENOMEM;
+
+	ip5xxx->dev = dev;
+	ip5xxx->regmap = regmap;
+	INIT_DELAYED_WORK(&ip5xxx->wd_work, ip5xxx_power_wd_work);
+
+	psy_cfg.of_node = dev->of_node;
+	psy_cfg.drv_data = ip5xxx;
+
+	psy = devm_power_supply_register(dev, &ip5xxx_boost_desc, &psy_cfg);
+	if (IS_ERR(psy))
+		return PTR_ERR(psy);
+
+	psy = devm_power_supply_register(dev, &ip5xxx_charger_desc, &psy_cfg);
+	if (IS_ERR(psy))
+		return PTR_ERR(psy);
+
+	ret = devm_add_action(dev, ip5xxx_power_cleanup, ip5xxx);
+	if (ret) {
+		ip5xxx_power_cleanup(ip5xxx);
+		dev_err(dev, "Failed to add cleanup action (%d)\n", ret);
+		return ret;
+	}
+
+	struct power_supply_battery_info* info_out = &ip5xxx->bat;
+	ret = power_supply_get_battery_info(psy, &info_out);
+ ip5xxx->bat = *info_out;
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get battery info\n");
+
+	if (ip5xxx->bat.factory_internal_resistance_uohm >= 0)
+		ip5xxx->r_int = ip5xxx->bat.factory_internal_resistance_uohm / 1000;
+	else
+		ip5xxx->r_int = 187;
+
+	schedule_delayed_work(&ip5xxx->wd_work, msecs_to_jiffies(500));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ip5xxx_power_probe_with_regmap);
+
+static int ip5xxx_power_probe(struct i2c_client *client)
+{
+	struct regmap* regmap;
+
+	regmap = devm_regmap_init_i2c(client, &ip5xxx_regmap_config);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	return ip5xxx_power_probe_with_regmap(&client->dev, regmap);
+}
+
+static const struct of_device_id ip5xxx_power_of_match[] = {
+	{ .compatible = "injoinic,ip5108" },
+	{ .compatible = "injoinic,ip5109" },
+	{ .compatible = "injoinic,ip5207" },
+	{ .compatible = "injoinic,ip5209" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ip5xxx_power_of_match);
+
+static struct i2c_driver ip5xxx_power_driver = {
+	.probe_new	= ip5xxx_power_probe,
+	.driver		= {
+		.name		= "ip5xxx-power",
+		.of_match_table	= ip5xxx_power_of_match,
+	}
+};
+module_i2c_driver(ip5xxx_power_driver);
+
+MODULE_AUTHOR("Samuel Holland <samuel@sholland.org>");
+MODULE_DESCRIPTION("Injoinic IP5xxx power supply driver");
+MODULE_LICENSE("GPL");
